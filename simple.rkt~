#lang racket
#|
    ===> PLEASE DO NOT DISTRIBUTE THE SOLUTIONS PUBLICLY <===

   We ask that solutions be distributed only locally -- on paper, on a
   password-protected webpage, etc.

   Students are required to adhere to the University Policy on Academic
   Standards and Cheating, to the University Statement on Plagiarism and the
   Documentation of Written Work, and to the Code of Student Conduct as
   delineated in the catalog of Undergraduate Programs. The Code is available
   online at:

   https://www.umb.edu/life_on_campus/dean_of_students/student_conduct

|#
;(require racket/trace)
(require "hw7-util.rkt")
(provide (all-defined-out))

(define/contract (env-put env var val)
  (-> handle? d:variable? d:value? eff-op?)
  (eff-op
   (lambda (mem)
     (eff
      (environ-put mem env var val)
      (d:void)))))

(define/contract (env-push env var val)
  (-> handle? d:variable? d:value? eff-op?)
  (eff-op
   (lambda (mem)
      (environ-push mem env var val))))

(define/contract (env-get env var)
  (-> handle? d:variable? eff-op?)
  (eff-op
   (lambda (mem)
     (eff
      mem
      (environ-get mem env var)))))
#|
      (d:closure? v)
      (d:bool? v)
      (d:builtin? v)))
|#
(define/contract (d:eval-exp env exp)
  (-> handle? d:expression? eff-op?)
    ;(printf "\n......exp:.......\n ~a" exp)
  ;(printf "\n......quoted-exp:.......\n ~a\n" (d:quote1 exp))
  (eff-op
   (lambda (mem)
     (match exp
      ;[_ (eff mem (d:void))]
      [(d:void)
       ;(display "/its a void")
       (eff mem (d:void))]       
      [(d:number n)
       ;(display "/its a number")
       (eff mem exp)]
      [(d:bool b)
       ;(display "/its a bool")
       (eff mem exp)]
      [(d:builtin f)
       ;(display "/its a builtin")
       (eff mem exp)]
      [(d:closure env decl)
       ;(display "/its a closure")
       (eff mem exp)]
      [(d:lambda params body)
       ;(display "/its a lambda\n")
       (eff mem (d:closure env exp))]
      [(d:variable name)
       ;(display "/its a variable")
       (eff-run (env-get env exp) mem)]
      [(d:apply
        (d:apply
         (d:apply (d:variable 'if) (list ec)) (list et)) (list ef))
       (eff-run
        (do
            branch <- ((d:eval-exp-impl) env ec)
            (match branch
              [(d:bool #f) (do
                   on-false <- ((d:eval-exp-impl) env ef)
                   (eff-pure on-false))]
              [_
               (do
                   on-true <- ((d:eval-exp-impl) env et)
                   (eff-pure on-true))]))
        mem)]
      [(d:apply func (list arg1 arg-r ...)) 
       ;(printf "\n......func: ~a" (d:quote1 func))
       ;(printf "\n......arg1: ~a" (d:quote1 arg1))
       ;(printf "\n......run-arg1: ~a" (d:quote1 arg1))
       (eff-run
        (do
         ef <- ((d:eval-exp-impl) env func)
         ;(printf ".....ef: ~a\n" ef)
         ea <- ((d:eval-exp-impl) env arg1)
         ;(printf "\n......ef: ~a" (d:quote1 ef))
         ;(printf "\n......ea: ~a" (d:quote1 ea))
         ;(display "\nafter ea")
         (match ef
           [(d:closure ef-env (d:lambda (list ef-x1 ef-x ...) ef-t))
            (do 
              body-env <- (env-push ef-env ef-x1 ea)
              ((d:eval-term-impl) body-env ef-t))]
           [(d:builtin f) (do (eff-pure (f ea)))]))
        mem)]))))
;(trace d:eval-exp)

(define/contract (d:eval-term env term)
  (-> handle? d:term? eff-op?)
  (eff-op
   (lambda (mem)
     (match term
       [(d:define x t) ;(display "\n.......d:define......\n\n")
        (eff-run
         (do
             v <- ((d:eval-exp-impl) env t)
             (env-put env x v)
             (eff-pure (d:void)))
         mem)]
       [(d:seq t1 t2) ;(display "\n.......d:seq......\n\n")
        (eff-run
         (do
             ((d:eval-term-impl) env t1)
             ((d:eval-term-impl) env t2))
         mem)]
       [_ (eff-run ((d:eval-exp-impl) env term) mem)]))))

;; Use this dynamic parameter in d:eval-term for improved testing (see Lecture 31)
(define d:eval-exp-impl (make-parameter d:eval-exp))
;; Use this dynamic parameter in d:eval-exp for improved testing (see Lecture 31)
(define d:eval-term-impl (make-parameter d:eval-term))

;; Parameter body *must* be a curried term already
(define/contract (break-lambda args body)
  (-> (listof d:variable?) d:term? d:lambda?)
  (match args
    [(list a1 ar ...)
     (define (break break-args break-body)
         (match break-args
           [(list break-arg1 break-args ...) (d:lambda (list break-arg1) (break break-args body))]
           [_ body]))
     (break args body)]
    [_ (d:lambda (list (d:variable '_)) body)]))

;; ef is a curried expression and args is a list of curried expressions
(define/contract (break-apply ef args)
  (-> d:expression? (listof d:expression?) d:expression?)
  ;(printf "\n......ef: ~a" ef)
  ;(printf "\n......args: ~a" args)
  (match args
    [(list x1 x2 ...)
     ;(printf "\n.....non-empty-args: ~a\n" args)
     (define (break break-ef break-args)
         (match break-args
           [(list x1 x2 ...) (break (d:apply break-ef (list x1)) x2)]
           [_ break-ef]))
     (break ef args)]
    [_ (d:apply ef (list (d:void)))]))

;; Use this dynamic parameter in d:curry for improved testing (see Lecture 31)
(define break-lambda-impl (make-parameter break-lambda))
;; Use this dynamic parameter in d:curry for improved testing (see Lecture 31)
(define break-apply-impl (make-parameter break-apply))

(define/contract (d:curry term)
  (-> d:term? d:term?)
  ;(printf "\n......quoted-term:.......\n ~a\n" term)
  (match term
      [(d:lambda l b) ((break-lambda-impl) (map d:curry l) (d:curry b))]
      [(d:apply f a) #|(printf "\n.....d:curry-f: ~a\n" f) (printf "\n.....d:curry-args: ~a\n" a)|#
       ((break-apply-impl) (d:curry f) (map d:curry a))]
      [(d:define x t) (d:define x (d:curry t))]
      [(d:seq t1 t2) (d:seq (d:curry t1) (d:curry t2))]
      [_ term]))
